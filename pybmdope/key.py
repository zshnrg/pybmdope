"""
key.py
This file is part of py-bmdope.
py-bmdope is a Python package for Block Metadata-Driven Order-Preserving Encryption (BMDOPE).
It provides functionalities for reshuffling keys and splitting them into subkeys.
"""

def rotate_left(byte, n):
    """
    Rotates the bits of a byte to the left by n positions.

    Args:
        byte (int): The 8-bit integer (0-255) to be rotated.
        n (int): The number of positions to rotate the bits to the left.

    Returns:
        int: The resulting byte after the left rotation.
    """
    return ((byte << n) | (byte >> (8 - n))) & 0xFF

def rotate_right(byte, n):
    """
    Rotates the bits of a byte to the right by n positions.

    Args:
        byte (int): The 8-bit integer (0-255) to be rotated.
        n (int): The number of positions to rotate the bits to the right.

    Returns:
        int: The resulting byte after the right rotation.
    """
    return ((byte >> n) | (byte << (8 - n))) & 0xFF

def reshuffle(key: bytes) -> bytes:
    """
    Reshuffles a 16-byte key using bitwise rotations, XOR mixing, and a fixed permutation.
    
    This function takes a 16-byte key and transforms it through a series of
    deterministic operations:
    1. Each byte is bitwise-rotated left or right based on its index.
    2. Each byte is then XORed with its adjacent neighbors (with wrap-around).
    3. The resulting bytes are reordered according to a fixed permutation map.
    
    This is typically used as part of a key scheduling or derivation algorithm.
    
    Args:
        key (bytes): The 16-byte key to be reshuffled.
    
    Returns:
        bytes: The reshuffled 16-byte key.
    
    Raises:
        ValueError: If the input key is not 16 bytes long or not a bytes object
                    or if the key contains non-byte values.
    """
    if not isinstance(key, bytes):
        raise ValueError("Key must be a bytes object.")
    if len(key) != 16:
        raise ValueError("Key must be 16 bytes long.")
    
    key_list = list(key)
    
    for i in range(16):
        if i % 2 == 0:
            key_list[i] = rotate_left(key_list[i], i % 8)
        else:
            key_list[i] = rotate_right(key_list[i], (16 - i) % 8)
    
    mixed_key = [0] * 16
    for i in range(16):
        mixed_key[i] = key_list[i] ^ key_list[(i - 1) % 16] ^ key_list[(i + 1) % 16]
    
    map_index = [13, 0, 15, 2, 8, 5, 10, 7, 3, 14, 6, 9, 12, 11, 4, 1]
    reshuffled = [mixed_key[map_index[i]] for i in range(16)]
    
    return bytes(reshuffled)

def split_key(key: bytes):
    """
    Splits a 16-byte key into subkeys for cryptographic operations.
    The function validates that the key is exactly 16 bytes long. It then
    divides the key into several components. The first 12 bytes are split
    into three 4-byte parts. A fourth part is generated by performing a
    bitwise XOR operation on the corresponding bytes of the first three parts.
    
    Args:
        key (bytes): The 16-byte key to be processed.
    
    Returns:
        tuple: A tuple containing two elements:
            - A list of four parts: The first three parts are 4-byte segments
              of the key (`bytes`). The fourth part is a 4-character string
              derived from the XOR of the first three parts.
            - The last 4 bytes of the original key (`bytes`).
    
    Raises:
        ValueError: If the input key is not 16 bytes long
                    or if the key is not a bytes object.    
    """
    if not isinstance(key, bytes):
        raise ValueError("Key must be a bytes object.")
    if len(key) != 16:
        raise ValueError("Key must be 16 characters long.")
    
    part1, part2, part3 = key[:4], key[4:8], key[8:12]
    part4 = bytes([
        part1[i] ^ part2[i] ^ part3[i] for i in range(4)
    ])
    return [part1, part2, part3, part4], key[12:16]
