"""
key.py
This file is part of py-bmdope.
py-bmdope is a Python package for Block Metadata-Driven Order-Preserving Encryption (BMDOPE).
It provides functionalities for reshuffling keys and splitting them into subkeys.
"""

def rotate_left(byte, n):
    """
    Rotates the bits of a byte to the left by n positions.

    Args:
        byte (int): The 8-bit integer (0-255) to be rotated.
        n (int): The number of positions to rotate the bits to the left.

    Returns:
        int: The resulting byte after the left rotation.
    """
    return ((byte << n) | (byte >> (8 - n))) & 0xFF

def rotate_right(byte, n):
    """
    Rotates the bits of a byte to the right by n positions.

    Args:
        byte (int): The 8-bit integer (0-255) to be rotated.
        n (int): The number of positions to rotate the bits to the right.

    Returns:
        int: The resulting byte after the right rotation.
    """
    return ((byte >> n) | (byte << (8 - n))) & 0xFF

def reshuffle(input_str):
    """
    Reshuffles a 16-byte string using bitwise rotations, XOR mixing, and a fixed permutation.
    
    This function takes a 16-character string and transforms it through a series of
    deterministic operations:
    1. Each byte is bitwise-rotated left or right based on its index.
    2. Each byte is then XORed with its adjacent neighbors (with wrap-around).
    3. The resulting bytes are reordered according to a fixed permutation map.
    
    This is typically used as part of a key scheduling or derivation algorithm.
    
    Args:
        input_str (str): The 16-character string to be reshuffled.
    
    Returns:
        str: The reshuffled 16-character string.
    
    Raises:
        ValueError: If the input string is not 16 characters long.
    """
    if len(input_str) != 16:
        raise ValueError("Input must be 16 bytes long.")
    
    byte_array = [ord(c) for c in input_str]
    for i in range(16):
        byte_array[i] = rotate_left(byte_array[i], i % 8) if i % 2 == 0 else rotate_right(byte_array[i], (16 - i) % 8)
    
    for i in range(16):
        byte_array[i] ^= byte_array[(i - 1) % 16] ^ byte_array[(i + 1) % 16]
    
    map_index = [13, 0, 15, 2, 8, 5, 10, 7, 3, 14, 6, 9, 12, 11, 4, 1]
    reshuffled = [byte_array[map_index[i]] for i in range(16)]
    
    return ''.join(chr(b) for b in reshuffled)

def split_key(key: str):
    """
    Splits a 16-character key into subkeys and a final part.
    
    The function divides the first 12 characters of the key into three 4-character
    parts. A fourth part is generated by XORing the corresponding characters of the
    first three parts.
    
    Args:
        key (str): The 16-character input key.
    
    Returns:
        tuple[list[str], str]: A tuple containing two elements:
            1. A list of four 4-character subkeys.
            2. The last 4 characters of the original key.
    
    Raises:
        ValueError: If the input key is not 16 characters long.
    """
    if len(key) != 16:
        raise ValueError("Key must be 16 characters long.")
    
    part1, part2, part3 = key[:4], key[4:8], key[8:12]
    part4 = ''.join(chr(ord(part1[i]) ^ ord(part2[i]) ^ ord(part3[i])) for i in range(4))
    return [part1, part2, part3, part4], key[12:16]
